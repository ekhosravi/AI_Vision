# -*- coding: utf-8 -*-
"""The best Source.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-cJt_06B2ZkV9mS89Fo3W3l6PHN26TkG
"""

#!pip install python-telegram-bot==13.3

import telegram
from telegram.ext import Updater, CommandHandler, InlineQueryHandler, CallbackQueryHandler, MessageHandler, Filters
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup,InlineQueryResultArticle, InputTextMessageContent, InputMediaPhoto, TelegramError
import requests
import re 

IMDB_USER_KEY = r'k_caremqr0'
My_TELEGRAM_BOT_TOKEN = '5871529813:AAHmsCetj5SukdH_N28zRNc3XkbAwVlBPDI'
#REQUEST_KW = {'proxy_url':'socks5h://127.0.0.1:9050'}
user_watchlist = {}

updater = Updater(My_TELEGRAM_BOT_TOKEN) 
dispatcher = updater.dispatcher

def start_handler(update, context):
    context.bot.send_message(chat_id=update.effective_chat.id, text="Hello {}, \n\n ðŸ’» I'm IMDB Bot! Use /help to see the list of commands.".format(update.message.chat.first_name))
    
def help(update, context):
    message = 'Choose an option:' 

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("ðŸ  Search Movie", switch_inline_query_current_chat="")],
        [InlineKeyboardButton("ðŸ›ï¸ View Watchlist", callback_data="View_Watchlist")],
    ])
    update.message.reply_text(message, reply_markup = keyboard)


def handle_Callback(update, context):
    query = update.callback_query
    data = query.data
    UserId = query.from_user.id

    if data == 'View_Watchlist':
        if UserId not in user_watchlist or not user_watchlist[UserId]:
            query.message.reply_text('watchlist is empty')
        else:
            crossIcon = u"\u274C"

            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton(f"{i+1} {title}", callback_data = f"movie_in_watchlist:{movie_Id}:{title}"),
                    InlineKeyboardButton(text=crossIcon , callback_data = f"delete_from_watchlist:{movie_Id}")
                ]
                for i, (movie_Id, title) in enumerate(user_watchlist[UserId].items())
            ])
            query.message.reply_text(" Your watchlist:", reply_markup = keyboard)

    elif data.startswith("delete_from_watchlist"):
      _, movie_Id = data.split(":" , 1)
      if UserId in user_watchlist and movie_Id in user_watchlist[UserId]:
          del user_watchlist[UserId][movie_Id]
          query.answer("Movie removed from list")
          query.data = "View_Watchlist"
          handle_Callback(update, context)
      else:
          query.answer("Movie is not in your watchlist")

    elif data.startswith("movie_in_watchlist"):
      _, movie_Id, title = data.split(":" , 2)
      query.answer(f" {title} is in your watchlist")

    elif data.startswith("add_to_watchlist"):
      _, movie_Id, title = data.split(":" , 2)

      if UserId not in user_watchlist:
          user_watchlist[UserId] = {}

      if movie_Id not in user_watchlist[UserId]:
          user_watchlist[UserId][movie_Id] = title
          query.answer(" Movie added to your watchlist")
      else:
          query.answer(" Movie befor added to your watchlist")

    elif data.startswith("view_images"):
        _, movie_Id, title = data.split(":" , 2)
        print(movie_Id)

        url_Of_Image = f"https://imdb-api.com/en/API/Images/{IMDB_USER_KEY}/{movie_Id}"  #https://imdb-api.com/API/Images/k_rnydgwuh/tt0110413/Full
        images_urls = requests.get(url_Of_Image).json()

        number_of_Image_WithoutErr = 7
        WhileIsTrue = True
        while WhileIsTrue:
          images = images_urls.get("items")[:number_of_Image_WithoutErr]
          
          try:
            if images:
                media_grp = [InputMediaPhoto(media=item["image"]) for item in images]
                query.bot.send_media_group(chat_id = query.message.chat_id, media = media_grp)
            else:
                query.answer(" No images are available for selected movie  OR   Failing in loading images")

            WhileIsTrue = False 
          except telegram.TelegramError as e:
            print('Show ERROR to Elham : ' , str(e))
            StrMsgEror = str(e)
            numbers_list = re.findall(r"\d+", StrMsgEror)

            if int(numbers_list[0]) > 1:
              print('number ', int(numbers_list[0]) - 1)
              number_of_Image_WithoutErr = int(numbers_list[0]) - 1
            else:
              WhileIsTrue = False

        trailer_url =  r"https://imdb-api.com/API/Trailer/{}/{}".format(IMDB_USER_KEY, movie_Id) #https://imdb-api.com/API/Trailer/k_rnydgwuh/tt0110413
        trailerResponse = requests.get(trailer_url).json()

        if not trailerResponse:
            return None

        trailorLink = trailerResponse.get("link")

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ðŸ”ª Watch Trailer", url = trailorLink) if trailorLink else InlineKeyboardButton('ðŸ”ª Trailer not available', callback_data="trailer_not_available"),
            InlineKeyboardButton("Add to Watchlist", callback_data=f"add_to_watchlist:{movie_Id}:{title}")]
        ])
    
        query.message.reply_text(f" *{title}* Movie Images", reply_markup = keyboard, parse_mode = "Markdown")

def Search_Movie_inline(update, context):
    query = update.inline_query.query
    IMDB_API = r"https://imdb-api.com/en/API/SearchMovie/{}/{}".format(IMDB_USER_KEY, query) #https://imdb-api.com/en/API/SearchMovie/k_rnydgwuh/leon%20the%20professional
    response = requests.get(IMDB_API).json()
 
    if not response:
        return None

    output = []
    for movie in response["results"]:
        output.append(InlineQueryResultArticle(id=movie['id'] , title=movie['title'] , 
                                               description=movie['description'] , 
                                               thumb_url=movie['image'], 
                                               input_message_content=InputTextMessageContent(movie['id'])))
    update.inline_query.answer(output)

def show_movie_Description(update, context):
  try:
    MovieId = update.message.text
    MessageId = update.message.message_id
    ChatId = update.message.chat_id

    IMDB_API = r"https://imdb-api.com/en/API/Title/{}/{}".format(IMDB_USER_KEY, MovieId)
    response = requests.get(IMDB_API).json()

    if not response:
        return None
 
    Description_Of_Movie = (
        f" ðŸ”· Tilte :  {response['fullTitle']} \n\n" 
        f" ðŸ”» Duration :  {response['runtimeStr']} \n\n"
        f" ðŸ”» Genres :  {response['genres']} \n"
        f" ðŸ”» Directors :  {response['directors']} \n"
        f" ðŸ”» Story Line :\n  {response['plot']} \n"
    )

    trailer_url =  r"https://imdb-api.com/API/Trailer/{}/{}".format(IMDB_USER_KEY, MovieId) #https://imdb-api.com/API/Trailer/k_rnydgwuh/tt0110413
    trailerResponse = requests.get(trailer_url).json()

    if not trailerResponse:
        return None

    trailorLink = trailerResponse.get("link")
    full_title = response['fullTitle']
    short_title = full_title[:30] + '...' if len(full_title) > 30 else full_title

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("âœ… View Images", callback_data=f"view_images:{MovieId}:{short_title}"),
        InlineKeyboardButton("ðŸ”ª Watch Trailer", url = trailorLink) if trailorLink else InlineKeyboardButton('ðŸ”ª Trailer not available', callback_data="trailer_not_available"),
        InlineKeyboardButton("Add to Watchlist", callback_data=f"add_to_watchlist:{MovieId}:{short_title}"),]
        ])
    update.message.reply_photo(photo = response['image'], caption=Description_Of_Movie, reply_markup=keyboard, parse_mode = "Markdown")
    context.bot.delete_message(chat_id = ChatId , message_id = MessageId)

  except SyntaxError as err1:
      print('Error   : ' , err1)

def main():
  dispatcher.add_handler(CommandHandler("start", start_handler))
  dispatcher.add_handler(CommandHandler("help", help))

  dispatcher.add_handler(CallbackQueryHandler(handle_Callback))
  dispatcher.add_handler(InlineQueryHandler(Search_Movie_inline))
  dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command , show_movie_Description))

  updater.start_polling(timeout=132)
  updater.idle()

if __name__ == "__main__":
  main()

import requests

IMDB_USER_KEY = r'k_caremqr0'
My_TELEGRAM_BOT_TOKEN = '5871529813:AAHmsCetj5SukdH_N28zRNc3XkbAwVlBPDI'
REQUEST_KW = {'proxy_url':'socks5h://127.0.0.1:9050'}
user_watch = {}
searchItem = 'The Mother' 

IMDB_API = r"https://imdb-api.com/API/Search/{}/{}".format(IMDB_USER_KEY, searchItem)
response = requests.get(IMDB_API)#.json()
 

feed = response.json()
feed

